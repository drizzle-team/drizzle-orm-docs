import Callout from '@/components/markdown/Callout.astro';

# FAQ & Troubleshooting

## Frequently Asked Questions

### **How do I apply migrations generated by drizzle-kit?**

Currently, you have several options on how to do it:

**Option 1**

Use the `migrate()` function from `drizzle-orm`
You can check **[this section](./overview#running-migrations)** for information on how to use the `migrate` function.

**Option 2**

Use your own or existing tool for migration management

You can check **[this section](./overview#migration-files)** of the documentation for the migration folder structure. 
You can read all SQL files from this folder and run each statement that has not already been applied in the database.
There are also plenty of tools that can emulate the same behavior.

<Callout>
    You currently can't apply migration files from a folder in `drizzle-kit`. This option will be available soon
</Callout>

---

### **Should I use `generate` or `push`?**

Those are logically 2 different commands. `generate` is used to create an sql file together with additional
information needed for `drizzle-kit` (or any other migration tool).

After generating those migrations, they won't be applied to a database. 
You need to do it in the next step. You can read more about it **[here](./faq#how-do-i-apply-migrations-generated-by-drizzle-kit)**

On the other hand, `push` doesn't need any migrations to be generated. It will
simply sync your schema with the database schema. Please be careful when using it;
we recommend it only for local development and local databases. To read more about it, check out **[`drizzle-kit push`](./overview#prototyping-with-db-push)**


## Troubleshooting

### **Using multiple schemas in PostgreSQL**

Currently, we have one limitation with managing multiple schemas in PostgreSQL. 
You can't create tables with the same name in different schemas. 
We are aware that this is the main purpose of schemas in PostgreSQL, and fixing this issue is a priority for us.

However, you can use schemas in PostgreSQL on the ORM level without any issues and with drizzle-kit,
without naming tables the same across schemas.

Another option, if you are using the `push:pg` command, is to bypass this limitation by using **[`schemaFilter`](./config-reference#schemafilter)**

For example, if you have two schemas: `public` and `internals`, and both schemas have a table named `logs`, 
you can specify schemaFilter to `public` and perform a schema push whenever something was changed in the `public` schema.
```ts
{
    schemaFilter: ["public"]
}
```
and then you can specify `schemaFilter` to `internals` and perform a schema push whenever something was changed in the `internals` schema.
```ts
{
    schemaFilter: ["internals"]
}
```

In this case no limitation will be for several schemas in PostgreSQL


### **Why aren't my CLI options being read by drizzle-kit?**

Drizzle Kit has a current set of priorities for reading config options:

1. If there is a `drizzle.config` file, read from it.
2. If there is no `drizzle.config` file, check for the `--config` option in the CLI.
3. If no `--config` option was found, use CLI options; otherwise, read from a defined config.

If you specify both config parameters and CLI options, an error will be thrown, and you should use 
either CLI options or have a config file defined in your project.

### `push:pg` command is attempting to apply changes even when there are no changes in the code

There are 2 known issues for `primaryKey` and `foreignKey`:

1. Before you have the possibility to define a custom name for the `primary key constraint`,
please ensure the following:

    - Define `.primaryKey()` on a column level if you have a single-column primary key.
    - Define `primaryKey()` in the 3rd parameter for pgTable only if you have 2 or more columns in the primary key.

2. Before you have the possibility to define a custom name for the foreign key constraint, 
you may encounter issues if the foreign key constraint name exceeds 64 characters. 

Drizzle generates the foreign key using the following pattern - `${tableFrom}_${columnsFrom}_${tableTo}_${columnsTo}`