import CodeTab from "@/components/markdown/CodeTab.astro";
import CodeTabs from "@/components/markdown/CodeTabs.astro";
import Section from "@/components/markdown/Section.astro";
import Tab from "@/components/markdown/Tab.astro";
import Tabs from "@/components/markdown/Tabs.astro";
import Callout from "@/components/markdown/Callout.astro";
import SchemaFilePaths from "@mdx/SchemaFilePaths.mdx"

# Configuration files
Drizzle Kit lets you declare configurations in `TypeScript`, `JavaScript` or `JSON` configuration files.  

You can have autocomplete experience and a very convenient environment variables flow!  

<Section>
```plaintext {5}
ðŸ“¦ <project root>
 â”œ ...
 â”œ ðŸ“‚ drizzle
 â”œ ðŸ“‚ src
 â”œ ðŸ“œ drizzle.config.ts
 â”” ðŸ“œ package.json
```
<CodeTabs items={["drizzle.config.ts", "drizzle.config.js", "drizzle.config.json"]}>
<CodeTab>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql"
  schema: "./src/schema.ts",
  out: "./drizzle",
});
```
</CodeTab>
<CodeTab>
```js
import type { Config } from "drizzle-kit";

/** @type { import("drizzle-kit").Config } */
export default {
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql"
  schema: "./src/schema.ts",
  out: "./drizzle",
};
```
</CodeTab>
<CodeTab>
```json
{
  "dialect": "postgresql",
  "schema": "./src/schema.ts",
  "out": "./drizzle",
}
```
</CodeTab>
</CodeTabs>
</Section>

## Schema files paths
`schema` param lets you define where your schema file/files live.  

You can have as many separate schema files as you want and define paths to them using 
**[`glob`](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs)**
 or array of globs syntax.

<SchemaFilePaths />


## Migrations folder
`out` param lets you define folder for your migrations, it's optional and `drizzle` by default.  
It's very useful since you can have many separate schemas for different databases in the same project 
and have different migration folders for them.  
  
Migration folder contains `.sql` migration files and `_meta` folder which is used by `drizzle-kit`
<Callout type="warning" emoji="âš ï¸">
	Don't delete any files manually, please refer to [`drizzle-kit drop`](/kit-docs/commands#drop-migration) command
</Callout>

<Section>
```plaintext {3}
ðŸ“¦ <project root>
 â”œ ...
 â”œ ðŸ“‚ drizzle
 â”‚ â”œ ðŸ“‚ _meta
 â”‚ â”œ ðŸ“œ user.ts 
 â”‚ â”œ ðŸ“œ post.ts 
 â”‚ â”” ðŸ“œ comment.ts 
 â”œ ðŸ“‚ src
 â”œ ðŸ“œ drizzle.config.ts
 â”” ðŸ“œ package.json
```
```ts {5}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql"
  schema: "./src/schema/*",
  out: "./drizzle",
});
```
</Section>

## SQL breakpoints
`breakpoints` param lets you enable/disable SQL statement breakpoints in generated migrations.

It's optional and `true` by default, 
it's necessary to properly apply migrations on databases, that do not support multiple DDL alternation statements in one transaction (MySQL, SQLite) 
and Drizzle ORM has to apply them sequentially one by one.
```sql {5}
CREATE TABLE `book` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`name` text
);
--> statement-breakpoint
CREATE TABLE `book_to_author` (
	`author_id` integer,
	`book_id` integer,
	PRIMARY KEY(`book_id`, `author_id`)
);
```
## Push and Pull
Drizzle Kit provides you **[introspect](/kit-docs/commands#introspect--pull)** and **[push](/kit-docs/commands#prototype--push)** APIs.  

We mirror connection params of database drivers.

<Tabs items={["Connection URI", "Connection params"]}>
<Tab>
```ts {8}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql"
  schema: "./src/schema/*",
  out: "./drizzle",
  dbCredentials: {
    url: process.env.DB_URL,
  }
});
```
<Callout type="info" emoji="â„¹ï¸">
When using the PlanetScale driver, your connection string must end with `?ssl={"rejectUnauthorized":true}` instead of `?sslaccept=strict`.
</Callout>

</Tab>
<Tab>
```ts {10-14}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/schema/*",
  out: "./drizzle",
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql"
  dbCredentials: {
    user: "postgres",
    password: process.env.DATABASE_PASSWORD,
    host: "127.0.0.1",
    port: 5432,
    database: "db",
  }
});
```
</Tab>
</Tabs>

## Multi-project schema
`tablesFilter` param lets you filter tables with **[`glob`](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs)** 
syntax for db **[`push`](/kit-docs/commands#prototype--push)** command. It's useful when you have only one database available for several separate projects with separate sql schemas.  

How to define multi-project tables with Drizzle ORM â€” **[see here.](/docs/goodies#multi-project-schema)**

<Section>
```ts {3}
import { serial, text, pgTableCreator } from 'drizzle-orm/pg-core';

const pgTable = pgTableCreator((name) => `project1_${name}`);

const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});
```
```ts {7}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/schema/*",
  out: "./drizzle",
  dialect: "mysql", // "mysql" | "sqlite" | "postgresql"
  dbCredentials: {
    url: process.env.DATABASE_URL,
  }
  tablesFilter: ["project1_*"],
});
```
</Section>

You can apply multiple `or` filters:
```ts
tablesFilter: ["project1_*", "project2_*"]
```
